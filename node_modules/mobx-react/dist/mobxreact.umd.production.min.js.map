{"version":3,"file":"mobxreact.umd.production.min.js","sources":["../src/utils/utils.ts","../src/observerClass.ts","../src/observer.tsx","../src/Provider.tsx","../src/inject.ts","../src/disposeOnUnmount.ts","../src/propTypes.ts","../src/index.ts"],"sourcesContent":["let symbolId = 0\nfunction createSymbol(name: string): symbol | string {\n    if (typeof Symbol === \"function\") {\n        return Symbol(name)\n    }\n    const symbol = `__$mobx-react ${name} (${symbolId})`\n    symbolId++\n    return symbol\n}\n\nconst createdSymbols = {}\nexport function newSymbol(name: string): symbol | string {\n    if (!createdSymbols[name]) {\n        createdSymbols[name] = createSymbol(name)\n    }\n    return createdSymbols[name]\n}\n\nexport function shallowEqual(objA: any, objB: any): boolean {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction is(x: any, y: any): boolean {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList = {\n    $$typeof: 1,\n    render: 1,\n    compare: 1,\n    type: 1,\n    childContextTypes: 1,\n    contextType: 1,\n    contextTypes: 1,\n    defaultProps: 1,\n    getDefaultProps: 1,\n    getDerivedStateFromError: 1,\n    getDerivedStateFromProps: 1,\n    mixins: 1,\n    displayName: 1,\n    propTypes: 1\n}\n\nexport function copyStaticProperties(base: object, target: object): void {\n    const protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base))\n    Object.getOwnPropertyNames(base).forEach(key => {\n        if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)\n        }\n    })\n}\n\n/**\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\n * @param target\n * @param prop\n * @param value\n */\nexport function setHiddenProp(target: object, prop: any, value: any): void {\n    if (!Object.hasOwnProperty.call(target, prop)) {\n        Object.defineProperty(target, prop, {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value\n        })\n    } else {\n        target[prop] = value\n    }\n}\n\n/**\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\n * and the handler provided by mobx-react\n */\nconst mobxMixins = newSymbol(\"patchMixins\")\nconst mobxPatchedDefinition = newSymbol(\"patchedDefinition\")\n\nexport interface Mixins extends Record<string, any> {\n    locks: number\n    methods: Array<Function>\n}\n\nfunction getMixins(target: object, methodName: string): Mixins {\n    const mixins = (target[mobxMixins] = target[mobxMixins] || {})\n    const methodMixins = (mixins[methodName] = mixins[methodName] || {})\n    methodMixins.locks = methodMixins.locks || 0\n    methodMixins.methods = methodMixins.methods || []\n    return methodMixins\n}\n\nfunction wrapper(realMethod: Function, mixins: Mixins, ...args: Array<any>) {\n    // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n    mixins.locks++\n\n    try {\n        let retVal\n        if (realMethod !== undefined && realMethod !== null) {\n            retVal = realMethod.apply(this, args)\n        }\n\n        return retVal\n    } finally {\n        mixins.locks--\n        if (mixins.locks === 0) {\n            mixins.methods.forEach(mx => {\n                mx.apply(this, args)\n            })\n        }\n    }\n}\n\nfunction wrapFunction(realMethod: Function, mixins: Mixins): (...args: Array<any>) => any {\n    const fn = function (...args: Array<any>) {\n        wrapper.call(this, realMethod, mixins, ...args)\n    }\n    return fn\n}\n\nexport function patch(target: object, methodName: string, mixinMethod: Function): void {\n    const mixins = getMixins(target, methodName)\n\n    if (mixins.methods.indexOf(mixinMethod) < 0) {\n        mixins.methods.push(mixinMethod)\n    }\n\n    const oldDefinition = Object.getOwnPropertyDescriptor(target, methodName)\n    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n        // already patched definition, do not repatch\n        return\n    }\n\n    const originalMethod = target[methodName]\n    const newDefinition = createDefinition(\n        target,\n        methodName,\n        oldDefinition ? oldDefinition.enumerable : undefined,\n        mixins,\n        originalMethod\n    )\n\n    Object.defineProperty(target, methodName, newDefinition)\n}\n\nfunction createDefinition(\n    target: object,\n    methodName: string,\n    enumerable: any,\n    mixins: Mixins,\n    originalMethod: Function\n): PropertyDescriptor {\n    let wrappedFunc = wrapFunction(originalMethod, mixins)\n\n    return {\n        [mobxPatchedDefinition]: true,\n        get: function () {\n            return wrappedFunc\n        },\n        set: function (value) {\n            if (this === target) {\n                wrappedFunc = wrapFunction(value, mixins)\n            } else {\n                // when it is an instance of the prototype/a child prototype patch that particular case again separately\n                // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n                // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n                // as the method for the instance\n                const newDefinition = createDefinition(this, methodName, enumerable, mixins, value)\n                Object.defineProperty(this, methodName, newDefinition)\n            }\n        },\n        configurable: true,\n        enumerable: enumerable\n    }\n}\n","import { PureComponent, Component } from \"react\"\nimport {\n    createAtom,\n    _allowStateChanges,\n    Reaction,\n    $mobx,\n    _allowStateReadsStart,\n    _allowStateReadsEnd\n} from \"mobx\"\nimport { isUsingStaticRendering } from \"mobx-react-lite\"\n\nimport { newSymbol, shallowEqual, setHiddenProp, patch } from \"./utils/utils\"\n\nconst mobxAdminProperty = $mobx || \"$mobx\"\nconst mobxObserverProperty = newSymbol(\"isMobXReactObserver\")\nconst mobxIsUnmounted = newSymbol(\"isUnmounted\")\nconst skipRenderKey = newSymbol(\"skipRender\")\nconst isForcingUpdateKey = newSymbol(\"isForcingUpdate\")\n\nexport function makeClassComponentObserver(\n    componentClass: React.ComponentClass<any, any>\n): React.ComponentClass<any, any> {\n    const target = componentClass.prototype\n\n    if (componentClass[mobxObserverProperty]) {\n        const displayName = getDisplayName(target)\n        console.warn(\n            `The provided component class (${displayName}) \n                has already been declared as an observer component.`\n        )\n    } else {\n        componentClass[mobxObserverProperty] = true\n    }\n\n    if (target.componentWillReact)\n        throw new Error(\"The componentWillReact life-cycle event is no longer supported\")\n    if (componentClass[\"__proto__\"] !== PureComponent) {\n        if (!target.shouldComponentUpdate) target.shouldComponentUpdate = observerSCU\n        else if (target.shouldComponentUpdate !== observerSCU)\n            // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n            throw new Error(\n                \"It is not allowed to use shouldComponentUpdate in observer based components.\"\n            )\n    }\n\n    // this.props and this.state are made observable, just to make sure @computed fields that\n    // are defined inside the component, and which rely on state or props, re-compute if state or props change\n    // (otherwise the computed wouldn't update and become stale on props change, since props are not observable)\n    // However, this solution is not without it's own problems: https://github.com/mobxjs/mobx-react/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aobservable-props-or-not+\n    makeObservableProp(target, \"props\")\n    makeObservableProp(target, \"state\")\n\n    const baseRender = target.render\n    target.render = function () {\n        return makeComponentReactive.call(this, baseRender)\n    }\n    patch(target, \"componentWillUnmount\", function () {\n        if (isUsingStaticRendering() === true) return\n        this.render[mobxAdminProperty]?.dispose()\n        this[mobxIsUnmounted] = true\n\n        if (!this.render[mobxAdminProperty]) {\n            // Render may have been hot-swapped and/or overriden by a subclass.\n            const displayName = getDisplayName(this)\n            console.warn(\n                `The reactive render of an observer class component (${displayName}) \n                was overriden after MobX attached. This may result in a memory leak if the \n                overriden reactive render was not properly disposed.`\n            )\n        }\n    })\n    return componentClass\n}\n\n// Generates a friendly name for debugging\nfunction getDisplayName(comp: any) {\n    return (\n        comp.displayName ||\n        comp.name ||\n        (comp.constructor && (comp.constructor.displayName || comp.constructor.name)) ||\n        \"<component>\"\n    )\n}\n\nfunction makeComponentReactive(render: any) {\n    if (isUsingStaticRendering() === true) return render.call(this)\n\n    /**\n     * If props are shallowly modified, react will render anyway,\n     * so atom.reportChanged() should not result in yet another re-render\n     */\n    setHiddenProp(this, skipRenderKey, false)\n    /**\n     * forceUpdate will re-assign this.props. We don't want that to cause a loop,\n     * so detect these changes\n     */\n    setHiddenProp(this, isForcingUpdateKey, false)\n\n    const initialName = getDisplayName(this)\n    const baseRender = render.bind(this)\n\n    let isRenderingPending = false\n\n    const reaction = new Reaction(`${initialName}.render()`, () => {\n        if (!isRenderingPending) {\n            // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n            // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n            // See #85 / Pull #44\n            isRenderingPending = true\n            if (this[mobxIsUnmounted] !== true) {\n                let hasError = true\n                try {\n                    setHiddenProp(this, isForcingUpdateKey, true)\n                    if (!this[skipRenderKey]) Component.prototype.forceUpdate.call(this)\n                    hasError = false\n                } finally {\n                    setHiddenProp(this, isForcingUpdateKey, false)\n                    if (hasError) reaction.dispose()\n                }\n            }\n        }\n    })\n\n    reaction[\"reactComponent\"] = this\n    reactiveRender[mobxAdminProperty] = reaction\n    this.render = reactiveRender\n\n    function reactiveRender() {\n        isRenderingPending = false\n        let exception = undefined\n        let rendering = undefined\n        reaction.track(() => {\n            try {\n                rendering = _allowStateChanges(false, baseRender)\n            } catch (e) {\n                exception = e\n            }\n        })\n        if (exception) {\n            throw exception\n        }\n        return rendering\n    }\n\n    return reactiveRender.call(this)\n}\n\nfunction observerSCU(nextProps: React.Props<any>, nextState: any): boolean {\n    if (isUsingStaticRendering()) {\n        console.warn(\n            \"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\"\n        )\n    }\n    // update on any state changes (as is the default)\n    if (this.state !== nextState) {\n        return true\n    }\n    // update if props are shallowly not equal, inspired by PureRenderMixin\n    // we could return just 'false' here, and avoid the `skipRender` checks etc\n    // however, it is nicer if lifecycle events are triggered like usually,\n    // so we return true here if props are shallowly modified.\n    return !shallowEqual(this.props, nextProps)\n}\n\nfunction makeObservableProp(target: any, propName: string): void {\n    const valueHolderKey = newSymbol(`reactProp_${propName}_valueHolder`)\n    const atomHolderKey = newSymbol(`reactProp_${propName}_atomHolder`)\n    function getAtom() {\n        if (!this[atomHolderKey]) {\n            setHiddenProp(this, atomHolderKey, createAtom(\"reactive \" + propName))\n        }\n        return this[atomHolderKey]\n    }\n    Object.defineProperty(target, propName, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            let prevReadState = false\n\n            if (_allowStateReadsStart && _allowStateReadsEnd) {\n                prevReadState = _allowStateReadsStart(true)\n            }\n            getAtom.call(this).reportObserved()\n\n            if (_allowStateReadsStart && _allowStateReadsEnd) {\n                _allowStateReadsEnd(prevReadState)\n            }\n\n            return this[valueHolderKey]\n        },\n        set: function set(v) {\n            if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\n                setHiddenProp(this, valueHolderKey, v)\n                setHiddenProp(this, skipRenderKey, true)\n                getAtom.call(this).reportChanged()\n                setHiddenProp(this, skipRenderKey, false)\n            } else {\n                setHiddenProp(this, valueHolderKey, v)\n            }\n        }\n    })\n}\n","import * as React from \"react\"\nimport { observer as observerLite, Observer } from \"mobx-react-lite\"\n\nimport { makeClassComponentObserver } from \"./observerClass\"\nimport { IReactComponent } from \"./types/IReactComponent\"\n\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for\n\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof React.forwardRef === \"function\" && React.forwardRef((props: any) => null)[\"$$typeof\"]\n\nconst ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof React.memo === \"function\" && React.memo((props: any) => null)[\"$$typeof\"]\n\n/**\n * Observer function / decorator\n */\nexport function observer<T extends IReactComponent>(component: T): T {\n    if (component[\"isMobxInjector\"] === true) {\n        console.warn(\n            \"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\"\n        )\n    }\n\n    if (ReactMemoSymbol && component[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\n            \"Mobx observer: You are trying to use 'observer' on a function component wrapped in either another observer or 'React.memo'. The observer already applies 'React.memo' for you.\"\n        )\n    }\n\n    // Unwrap forward refs into `<Observer>` component\n    // we need to unwrap the render, because it is the inner render that needs to be tracked,\n    // not the ForwardRef HoC\n    if (ReactForwardRefSymbol && component[\"$$typeof\"] === ReactForwardRefSymbol) {\n        const baseRender = component[\"render\"]\n        if (typeof baseRender !== \"function\")\n            throw new Error(\"render property of ForwardRef was not a function\")\n        return React.forwardRef(function ObserverForwardRef() {\n            const args = arguments\n            return <Observer>{() => baseRender.apply(undefined, args)}</Observer>\n        }) as T\n    }\n\n    // Function component\n    if (\n        typeof component === \"function\" &&\n        (!component.prototype || !component.prototype.render) &&\n        !component[\"isReactClass\"] &&\n        !Object.prototype.isPrototypeOf.call(React.Component, component)\n    ) {\n        return observerLite(component as React.StatelessComponent<any>) as T\n    }\n\n    return makeClassComponentObserver(component as React.ComponentClass<any, any>) as T\n}\n","import React from \"react\"\nimport { shallowEqual } from \"./utils/utils\"\nimport { IValueMap } from \"./types/IValueMap\"\n\nexport const MobXProviderContext = React.createContext<IValueMap>({})\n\nexport interface ProviderProps extends IValueMap {\n    children: React.ReactNode\n}\n\nexport function Provider(props: ProviderProps) {\n    const { children, ...stores } = props\n    const parentValue = React.useContext(MobXProviderContext)\n    const mutableProviderRef = React.useRef({ ...parentValue, ...stores })\n    const value = mutableProviderRef.current\n\n    if (__DEV__) {\n        const newValue = { ...value, ...stores } // spread in previous state for the context based stores\n        if (!shallowEqual(value, newValue)) {\n            throw new Error(\n                \"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\"\n            )\n        }\n    }\n\n    return <MobXProviderContext.Provider value={value}>{children}</MobXProviderContext.Provider>\n}\n\nProvider.displayName = \"MobXProvider\"\n","import React from \"react\"\nimport { observer } from \"./observer\"\nimport { copyStaticProperties } from \"./utils/utils\"\nimport { MobXProviderContext } from \"./Provider\"\nimport { IReactComponent } from \"./types/IReactComponent\"\nimport { IValueMap } from \"./types/IValueMap\"\nimport { IWrappedComponent } from \"./types/IWrappedComponent\"\nimport { IStoresToProps } from \"./types/IStoresToProps\"\n\n/**\n * Store Injection\n */\nfunction createStoreInjector(\n    grabStoresFn: IStoresToProps,\n    component: IReactComponent<any>,\n    injectNames: string,\n    makeReactive: boolean\n): IReactComponent<any> {\n    // Support forward refs\n    let Injector: IReactComponent<any> = React.forwardRef((props, ref) => {\n        const newProps = { ...props }\n        const context = React.useContext(MobXProviderContext)\n        Object.assign(newProps, grabStoresFn(context || {}, newProps) || {})\n\n        if (ref) {\n            newProps.ref = ref\n        }\n\n        return React.createElement(component, newProps)\n    })\n\n    if (makeReactive) Injector = observer(Injector)\n    Injector[\"isMobxInjector\"] = true // assigned late to suppress observer warning\n\n    // Static fields from component should be visible on the generated Injector\n    copyStaticProperties(component, Injector)\n    Injector[\"wrappedComponent\"] = component\n    Injector.displayName = getInjectName(component, injectNames)\n    return Injector\n}\n\nfunction getInjectName(component: IReactComponent<any>, injectNames: string): string {\n    let displayName\n    const componentName =\n        component.displayName ||\n        component.name ||\n        (component.constructor && component.constructor.name) ||\n        \"Component\"\n    if (injectNames) displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\"\n    else displayName = \"inject(\" + componentName + \")\"\n    return displayName\n}\n\nfunction grabStoresByName(\n    storeNames: Array<string>\n): (baseStores: IValueMap, nextProps: React.Props<any>) => React.PropsWithRef<any> | undefined {\n    return function (baseStores, nextProps) {\n        storeNames.forEach(function (storeName) {\n            if (\n                storeName in nextProps // prefer props over stores\n            )\n                return\n            if (!(storeName in baseStores))\n                throw new Error(\n                    \"MobX injector: Store '\" +\n                        storeName +\n                        \"' is not available! Make sure it is provided by some Provider\"\n                )\n            nextProps[storeName] = baseStores[storeName]\n        })\n        return nextProps\n    }\n}\n\nexport function inject(\n    ...stores: Array<string>\n): <T extends IReactComponent<any>>(\n    target: T\n) => T & (T extends IReactComponent<infer P> ? IWrappedComponent<P> : never)\nexport function inject<S, P, I, C>(\n    fn: IStoresToProps<S, P, I, C>\n): <T extends IReactComponent>(target: T) => T & IWrappedComponent<P>\n\n/**\n * higher order component that injects stores to a child.\n * takes either a varargs list of strings, which are stores read from the context,\n * or a function that manually maps the available stores from the context to props:\n * storesToProps(mobxStores, props, context) => newProps\n */\nexport function inject(/* fn(stores, nextProps) or ...storeNames */ ...storeNames: Array<any>) {\n    if (typeof arguments[0] === \"function\") {\n        let grabStoresFn = arguments[0]\n        return (componentClass: React.ComponentClass<any, any>) =>\n            createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true)\n    } else {\n        return (componentClass: React.ComponentClass<any, any>) =>\n            createStoreInjector(\n                grabStoresByName(storeNames),\n                componentClass,\n                storeNames.join(\"-\"),\n                false\n            )\n    }\n}\n","import React from \"react\"\nimport { patch, newSymbol } from \"./utils/utils\"\n\ntype Disposer = () => void\n\nconst protoStoreKey = newSymbol(\"disposeOnUnmountProto\")\nconst instStoreKey = newSymbol(\"disposeOnUnmountInst\")\n\nfunction runDisposersOnWillUnmount() {\n    ;[...(this[protoStoreKey] || []), ...(this[instStoreKey] || [])].forEach(propKeyOrFunction => {\n        const prop =\n            typeof propKeyOrFunction === \"string\" ? this[propKeyOrFunction] : propKeyOrFunction\n        if (prop !== undefined && prop !== null) {\n            if (Array.isArray(prop)) prop.map(f => f())\n            else prop()\n        }\n    })\n}\n\nexport function disposeOnUnmount(target: React.Component<any, any>, propertyKey: PropertyKey): void\nexport function disposeOnUnmount<TF extends Disposer | Array<Disposer>>(\n    target: React.Component<any, any>,\n    fn: TF\n): TF\n\nexport function disposeOnUnmount(\n    target: React.Component<any, any>,\n    propertyKeyOrFunction: PropertyKey | Disposer | Array<Disposer>\n): PropertyKey | Disposer | Array<Disposer> | void {\n    if (Array.isArray(propertyKeyOrFunction)) {\n        return propertyKeyOrFunction.map(fn => disposeOnUnmount(target, fn))\n    }\n\n    const c = Object.getPrototypeOf(target).constructor\n    const c2 = Object.getPrototypeOf(target.constructor)\n    // Special case for react-hot-loader\n    const c3 = Object.getPrototypeOf(Object.getPrototypeOf(target))\n    if (\n        !(\n            c === React.Component ||\n            c === React.PureComponent ||\n            c2 === React.Component ||\n            c2 === React.PureComponent ||\n            c3 === React.Component ||\n            c3 === React.PureComponent\n        )\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\"\n        )\n    }\n\n    if (\n        typeof propertyKeyOrFunction !== \"string\" &&\n        typeof propertyKeyOrFunction !== \"function\" &&\n        !Array.isArray(propertyKeyOrFunction)\n    ) {\n        throw new Error(\n            \"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\"\n        )\n    }\n\n    // decorator's target is the prototype, so it doesn't have any instance properties like props\n    const isDecorator = typeof propertyKeyOrFunction === \"string\"\n\n    // add property key / function we want run (disposed) to the store\n    const componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey]\n    const store = isDecorator\n        ? // decorators are added to the prototype store\n          target[protoStoreKey] || (target[protoStoreKey] = [])\n        : // functions are added to the instance store\n          target[instStoreKey] || (target[instStoreKey] = [])\n\n    store.push(propertyKeyOrFunction)\n\n    // tweak the component class componentWillUnmount if not done already\n    if (!componentWasAlreadyModified) {\n        patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount)\n    }\n\n    // return the disposer as is if invoked as a non decorator\n    if (typeof propertyKeyOrFunction !== \"string\") {\n        return propertyKeyOrFunction\n    }\n}\n","import { isObservableArray, isObservableObject, isObservableMap, untracked } from \"mobx\"\n\n// Copied from React.PropTypes\nfunction createChainableTypeChecker(validator: React.Validator<any>): React.Requireable<any> {\n    function checkType(\n        isRequired: boolean,\n        props: any,\n        propName: string,\n        componentName: string,\n        location: string,\n        propFullName: string,\n        ...rest: any[]\n    ) {\n        return untracked(() => {\n            componentName = componentName || \"<<anonymous>>\"\n            propFullName = propFullName || propName\n            if (props[propName] == null) {\n                if (isRequired) {\n                    const actual = props[propName] === null ? \"null\" : \"undefined\"\n                    return new Error(\n                        \"The \" +\n                            location +\n                            \" `\" +\n                            propFullName +\n                            \"` is marked as required \" +\n                            \"in `\" +\n                            componentName +\n                            \"`, but its value is `\" +\n                            actual +\n                            \"`.\"\n                    )\n                }\n                return null\n            } else {\n                // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise\n                return validator(props, propName, componentName, location, propFullName, ...rest)\n            }\n        })\n    }\n\n    const chainedCheckType: any = checkType.bind(null, false)\n    // Add isRequired to satisfy Requirable\n    chainedCheckType.isRequired = checkType.bind(null, true)\n    return chainedCheckType\n}\n\n// Copied from React.PropTypes\nfunction isSymbol(propType: any, propValue: any): boolean {\n    // Native Symbol.\n    if (propType === \"symbol\") {\n        return true\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n        return true\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n        return true\n    }\n\n    return false\n}\n\n// Copied from React.PropTypes\nfunction getPropType(propValue: any): string {\n    const propType = typeof propValue\n    if (Array.isArray(propValue)) {\n        return \"array\"\n    }\n    if (propValue instanceof RegExp) {\n        // Old webkits (at least until Android 4.0) return 'function' rather than\n        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n        // passes PropTypes.object.\n        return \"object\"\n    }\n    if (isSymbol(propType, propValue)) {\n        return \"symbol\"\n    }\n    return propType\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\nfunction getPreciseType(propValue: any): string {\n    const propType = getPropType(propValue)\n    if (propType === \"object\") {\n        if (propValue instanceof Date) {\n            return \"date\"\n        } else if (propValue instanceof RegExp) {\n            return \"regexp\"\n        }\n    }\n    return propType\n}\n\nfunction createObservableTypeCheckerCreator(\n    allowNativeType: any,\n    mobxType: any\n): React.Requireable<any> {\n    return createChainableTypeChecker((props, propName, componentName, location, propFullName) => {\n        return untracked(() => {\n            if (allowNativeType) {\n                if (getPropType(props[propName]) === mobxType.toLowerCase()) return null\n            }\n            let mobxChecker\n            switch (mobxType) {\n                case \"Array\":\n                    mobxChecker = isObservableArray\n                    break\n                case \"Object\":\n                    mobxChecker = isObservableObject\n                    break\n                case \"Map\":\n                    mobxChecker = isObservableMap\n                    break\n                default:\n                    throw new Error(`Unexpected mobxType: ${mobxType}`)\n            }\n            const propValue = props[propName]\n            if (!mobxChecker(propValue)) {\n                const preciseType = getPreciseType(propValue)\n                const nativeTypeExpectationMessage = allowNativeType\n                    ? \" or javascript `\" + mobxType.toLowerCase() + \"`\"\n                    : \"\"\n                return new Error(\n                    \"Invalid prop `\" +\n                        propFullName +\n                        \"` of type `\" +\n                        preciseType +\n                        \"` supplied to\" +\n                        \" `\" +\n                        componentName +\n                        \"`, expected `mobx.Observable\" +\n                        mobxType +\n                        \"`\" +\n                        nativeTypeExpectationMessage +\n                        \".\"\n                )\n            }\n            return null\n        })\n    })\n}\n\nfunction createObservableArrayOfTypeChecker(\n    allowNativeType: boolean,\n    typeChecker: React.Validator<any>\n) {\n    return createChainableTypeChecker(\n        (props, propName, componentName, location, propFullName, ...rest) => {\n            return untracked(() => {\n                if (typeof typeChecker !== \"function\") {\n                    return new Error(\n                        \"Property `\" +\n                            propFullName +\n                            \"` of component `\" +\n                            componentName +\n                            \"` has \" +\n                            \"invalid PropType notation.\"\n                    )\n                } else {\n                    let error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(\n                        props,\n                        propName,\n                        componentName,\n                        location,\n                        propFullName\n                    )\n\n                    if (error instanceof Error) return error\n                    const propValue = props[propName]\n                    for (let i = 0; i < propValue.length; i++) {\n                        error = (typeChecker as React.Validator<any>)(\n                            propValue,\n                            i as any,\n                            componentName,\n                            location,\n                            propFullName + \"[\" + i + \"]\",\n                            ...rest\n                        )\n                        if (error instanceof Error) return error\n                    }\n\n                    return null\n                }\n            })\n        }\n    )\n}\n\nconst observableArray = createObservableTypeCheckerCreator(false, \"Array\")\nconst observableArrayOf = createObservableArrayOfTypeChecker.bind(null, false)\nconst observableMap = createObservableTypeCheckerCreator(false, \"Map\")\nconst observableObject = createObservableTypeCheckerCreator(false, \"Object\")\nconst arrayOrObservableArray = createObservableTypeCheckerCreator(true, \"Array\")\nconst arrayOrObservableArrayOf = createObservableArrayOfTypeChecker.bind(null, true)\nconst objectOrObservableObject = createObservableTypeCheckerCreator(true, \"Object\")\n\nexport const PropTypes = {\n    observableArray,\n    observableArrayOf,\n    observableMap,\n    observableObject,\n    arrayOrObservableArray,\n    arrayOrObservableArrayOf,\n    objectOrObservableObject\n}\n","import { observable } from \"mobx\"\nimport { Component } from \"react\"\n\nif (!Component) throw new Error(\"mobx-react requires React to be available\")\nif (!observable) throw new Error(\"mobx-react requires mobx to be available\")\n\nexport {\n    Observer,\n    useObserver,\n    useAsObservableSource,\n    useLocalStore,\n    isUsingStaticRendering,\n    useStaticRendering,\n    enableStaticRendering,\n    observerBatching,\n    useLocalObservable\n} from \"mobx-react-lite\"\n\nexport { observer } from \"./observer\"\n\nexport { MobXProviderContext, Provider, ProviderProps } from \"./Provider\"\nexport { inject } from \"./inject\"\nexport { disposeOnUnmount } from \"./disposeOnUnmount\"\nexport { PropTypes } from \"./propTypes\"\nexport { IWrappedComponent } from \"./types/IWrappedComponent\"\n"],"names":["symbolId","createdSymbols","newSymbol","name","Symbol","symbol","createSymbol","shallowEqual","objA","objB","is","keysA","Object","keys","keysB","length","i","hasOwnProperty","call","x","y","hoistBlackList","$$typeof","render","compare","type","childContextTypes","contextType","contextTypes","defaultProps","getDefaultProps","getDerivedStateFromError","getDerivedStateFromProps","mixins","displayName","propTypes","setHiddenProp","target","prop","value","defineProperty","enumerable","configurable","writable","mobxMixins","mobxPatchedDefinition","wrapper","realMethod","args","locks","retVal","apply","this","methods","forEach","mx","_this","wrapFunction","patch","methodName","mixinMethod","methodMixins","getMixins","indexOf","push","oldDefinition","getOwnPropertyDescriptor","newDefinition","createDefinition","originalMethod","wrappedFunc","get","set","undefined","mobxAdminProperty","$mobx","mobxObserverProperty","mobxIsUnmounted","skipRenderKey","isForcingUpdateKey","makeClassComponentObserver","componentClass","prototype","getDisplayName","console","warn","componentWillReact","Error","PureComponent","shouldComponentUpdate","observerSCU","makeObservableProp","baseRender","makeComponentReactive","isUsingStaticRendering","dispose","comp","constructor","initialName","bind","isRenderingPending","reaction","Reaction","hasError","Component","forceUpdate","reactiveRender","exception","rendering","track","_allowStateChanges","e","nextProps","nextState","state","props","propName","valueHolderKey","atomHolderKey","getAtom","createAtom","prevReadState","_allowStateReadsStart","_allowStateReadsEnd","reportObserved","v","reportChanged","hasSymbol","ReactForwardRefSymbol","React","ReactMemoSymbol","observer","component","arguments","Observer","isPrototypeOf","observerLite","MobXProviderContext","createContext","Provider","children","stores","parentValue","useContext","mutableProviderRef","useRef","current","createStoreInjector","grabStoresFn","injectNames","makeReactive","base","protoProps","Injector","forwardRef","ref","newProps","context","assign","createElement","getOwnPropertyNames","getPrototypeOf","key","componentName","getInjectName","grabStoresByName","storeNames","baseStores","storeName","protoStoreKey","instStoreKey","runDisposersOnWillUnmount","propKeyOrFunction","Array","isArray","map","f","createChainableTypeChecker","validator","checkType","isRequired","location","propFullName","rest","untracked","chainedCheckType","getPropType","propValue","propType","RegExp","isSymbol","createObservableTypeCheckerCreator","allowNativeType","mobxType","toLowerCase","mobxChecker","isObservableArray","isObservableObject","isObservableMap","preciseType","Date","getPreciseType","nativeTypeExpectationMessage","createObservableArrayOfTypeChecker","typeChecker","error","PropTypes","observableArray","observableArrayOf","observableMap","observableObject","arrayOrObservableArray","arrayOrObservableArrayOf","objectOrObservableObject","observable","disposeOnUnmount","propertyKeyOrFunction","fn","c","c2","c3","componentWasAlreadyModified","join"],"mappings":"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"}